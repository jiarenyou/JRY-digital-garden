---
title: 第3课 Scaling Law & 模型计算量介绍
draft: false
tags:
  - AI
---
 

<iframe width="560" height="315" src="https://player.bilibili.com/player.html?autoplay=0&bvid=BV1LmPke1EKe" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"></iframe>
---

## 1. Scaling Law (扩展定律) 核心思想 
`Scaling Law`（扩展定律）最初由 `OpenAI` 提出，`DeepMind` 也有自己的版本。它是大模型领域从业者必须了解的基础概念。
![image.png](https://build-web.oss-cn-qingdao.aliyuncs.com/my_pic_file/20250713140128.png)

- **核心定义**: 大模型的性能（通常用损失值 `Loss` 来衡量，`Loss` 越低性能越好）与三个关键因素呈幂率关系（Power Law）：
    1.  **模型大小 (Model Size)**: 即模型的参数数量。
    2.  **数据集大小 (Dataset Size)**: 用于训练的数据量。
    3.  **计算量 (Compute)**: 用于训练的计算资源总量。

- **简单理解**: 当模型的参数量、训练数据的数量和投入的计算资源（如 GPU 数量和训练时间）同时增长时，模型的性能会随之提升。

- **当前价值**: 尽管 `Scaling Law` 是一个 foundational 的概念，但其在当今的重要性有所下降。最新的研究，特别是来自 `Meta` (`Llama 3`) 的成果表明，**数据质量**的影响可能超越了定律中对数据数量的简单考量。尽管如此，理解 `Scaling Law` 仍然对于把握大模型训练的宏观规律至关重要。

## 2. Scaling Law 的关键变量与关系 
`Scaling Law` 主要关注两个核心变量：

- **N (模型参数量)**: 指 `Transformer` 模型中所有可训练参数的总和，主要包括权重（`weights`）和偏置项（`biases`）。例如，QKV 矩阵、词嵌入、前馈网络（`Feed-Forward Network`）等都包含大量参数。我们常说的百亿、千亿参数模型，指的就是 `N` 的大小。

- **D (数据集大小)**: 指用于训练的数据集的规模，单位通常是 `token`。`Token` 是模型处理文本的基本单元。
    - 举例：通常 75 个汉字或英文单词约等于 100 个 `tokens`（比例约为 0.75:1）。

- **关系图解**:
    - 随着计算量（横轴，单位 `Petaflop-days`）的增加，模型的尺寸（纵轴，参数量）也呈现出准线性的增长。
    - 这种趋势适用于不同类型的模型，包括语言模型（`Language`）、多模态模型（`Multimodal`）、图像模型（`Image`）和视频模型（`Video`），它们都遵循相似的扩展规律。

## 3. 模型计算量 FLOPs 的概念 
- **FLOPs (Floating-point Operations per Second)**: 每秒浮点运算次数。这是衡量计算硬件（尤其是 GPU）性能的核心指标。浮点数是计算机中用于表示小数的一种方式。
    - 训练大模型通常需要多台 GPU 并行工作，因此总的计算能力可以用 `FLOPs` 来衡量。

- **论文图解分析**:
    1.  **计算量 vs. 模型尺寸**:
        - 在一个坐标系中，横轴为计算量，纵轴为模型参数量。
        - 存在一条“最佳性能线”。在这条线上，模型的尺寸和所需的计算量达到一个最优配比。
        - 如果偏离这条线，例如模型参数过大而计算量不足，或计算量过大而模型太小，都会导致效率降低。
    2.  **损失值 vs. 模型尺寸**:
        - 在另一个坐标系中，横轴为模型尺寸，纵轴为损失值（`Loss`）。
        - 不同的曲线代表不同的总计算量投入。
        - **结论**: 投入的计算资源越多（训练得越充分），模型的最终损失值就越低，性能越好。这与模型参数量的大小无关，即便是小模型，只要计算给足，性能也会更好。

## 4. 大模型参数量的发展历程 
模型的参数量在过去几年呈爆炸式增长，这印证了 `Scaling Law` 的趋势。

- **2018年**:
    - `BERT` (Google): 3.4亿参数，基于 `Encoder` + `Decoder` 架构，主要用于翻译任务。
    - `GPT-1` (OpenAI): 1.17亿参数，仅使用 `Decoder` 架构，但效果优于 `BERT`。
- **后续发展**:
    - `GPT-2`: 增长至 15亿 (1.5B) 参数。
    - `T5` (Google): 规模相对较小。
    - `GPT-3`: 暴增至 1750亿 (175B) 参数。
    - `GPT-4`: 据传达到 1.7万亿 (1.7T) 参数，很可能采用了多专家模型（`Mixture of Experts, MoE`）架构。
    - `Gemini` (Google): 达到 1.56万亿 (1.56T) 参数。
- **趋势**: 早期由 `OpenAI` 和 `Google` 主导，模型尺寸和所需的数据集、训练资源同步急剧增大，模型的表现也越来越好。

## 5. DeepMind 的 Scaling Law 公式与应用 
`DeepMind` 对 `Scaling Law` 提出了一个更具体的数学公式，可以用来预估模型的性能和训练成本。

- **公式**:
  $$
  L(N, D) = E + \frac{A}{N^\alpha} + \frac{B}{D^\beta}
  $$
  - `L(N, D)`: 模型在参数量为 `N`、数据集大小为 `D` 时的预测损失值（`Loss`）。
  - `E, A, B, α, β`: 通过对超过400个模型的训练数据进行拟合得出的常数。
    - `E ≈ 1.69`
    - `A ≈ 406.4`
    - `B ≈ 410.7`
    - `α ≈ 0.34`
    - `β ≈ 0.28`

- **应用实例：计算 Llama 3 (7B) 的预测损失值**:
    - **参数**:
        - 模型参数量 `N` = 70亿 (7B)。
        - 训练 `token` 数 `D` = 15万亿 (15T)。
    - **计算**: 将 `N` 和 `D` 的值代入上述公式。
    - **结果**: 预测的损失值 `Loss ≈ 1.86`。
    - **意义**: 这个公式使得我们可以在训练开始前，根据计划投入的参数量和数据量，大致估算出模型的性能水平，从而帮助制定预算和资源分配策略。

## 6. Chinchilla Law: 数据与参数的最佳配比 
`Chinchilla Law` 是 `DeepMind` 在 `Scaling Law` 研究中提出的一个重要发现，它关注于数据和参数之间的最优比例。

- **核心观点 (Chinchilla 规则)**: 为了达到最优的计算效率，训练数据的 `token` 数量 (`D`) 和模型的参数量 (`N`) 之间应该保持一个大约 **20:1** 的比例。
  $$
  D \approx 20 \times N
  $$
  - **示例**: 训练一个 100亿（10B）参数的模型，大约需要 2000亿（200B）`tokens` 的数据。`GPT-3` (175B 参数, 300B `tokens`) 和早期的 `LLaMA` 模型大致遵循此规律。

- **现代模型的突破**:
    - **`Llama 3` 的实践**: `Meta` 在训练 `Llama 3` 时，远超了这个比例。例如，70B 模型使用了 15T `tokens`，比例高达 **214:1**。
    - **原因**: **数据质量的重要性日益凸显**。`Meta` 指出，他们对 15T 的 `tokens` 进行了大量的预处理和筛选，确保了极高的质量。高质量的数据比单纯满足一个固定的数量比例能带来更好的模型性能。
    - **结论**: `Scaling Law` 和 `Chinchilla Law` 为资源分配提供了基准，但**高质量、经过精心清洗和筛选的数据**是提升现代大模型性能的更关键因素。

## 7. 模型训练计算量的估算
我们可以估算训练一个大模型所需的总计算量，并以此推算时间和成本。

- **简化估算公式**:
  $$
  C_{\text{FLOPs}} \approx 6 \times N \times D
  $$
  - `C`: 训练所需的总浮点运算次数 (Total FLOPs)。
  - `N`: 模型参数量。
  - `D`: 训练数据集的 `token` 数量。
- **“6倍”的来源**: 一次完整的训练迭代包含前向传播和反向传播。
    - **前向传播 (Forward Pass)**: 计算量约为 `2 × N × D`。
    - **反向传播 (Backward Pass)**: 计算量约为 `4 × N × D`，是前向传播的两倍，因为它涉及梯度计算和参数更新，计算更复杂。

- **实例：估算 GPT-4 训练时间**:
    - **已知信息**:
        - `N` ≈ 1.7万亿 (1.7T)
        - `D` ≈ 13万亿 (13T)
        - 硬件: 25,000 张 `NVIDIA A100` GPU
    - **计算过程**:
        1. 使用 `6ND` 公式计算出总 `FLOPs`。
        2. 查询单张 `A100` 的 `FLOPs` 性能。
        3. 用总 `FLOPs` 除以 (GPU 数量 × 单卡性能)，再换算成天数。
    - **结果**: 约 **98天**，即超过3个月。这个估算结果与外界传闻的 `GPT-4` 训练时间相符。
- **计算单位 PF-days**:  PetaFLOPs-days是一个衡量巨大计算量的单位。
    $$1 PetaFLOP/s = 10^{15}` FLOPs/s$$$$1 PF-day = (10^{15} \text{ FLOPs/s}) \times (86400 \text{ s/day}) \approx 8.64 \times 10^{19}FLOPs$$

## 8. GPU 性能与训练精度 
GPU 的性能和训练时使用的数值精度直接影响训练速度和成本。

- **GPU 性能对比 (`A100` vs `H100`)**:
    - `NVIDIA H100` 是 `A100` 的下一代产品，性能有显著提升。
    - 以 `FP32` (32位浮点) 精度为例，`H100` 的性能大约是 `A100` 的 **3.4倍**。这意味着使用 `H100` 可以将原本需要3个月的训练时间缩短到约1个月。

- **数值精度 (Precision)**:
    - **`FP32` (32-bit Floating Point)**: 精度高，是 `PyTorch` 等框架的默认精度，常用于模型的基础预训练。
    - **`FP16` (16-bit Floating Point) / `BFloat16`**: 精度较低，但计算速度更快，占用显存更少。
    - **`INT8` / `INT4` (8/4-bit Integer)**: 更低的精度，通过“量化”（Quantization）技术实现，能极大压缩模型大小，降低推理成本。

- **不同阶段的精度选择**:
    - **预训练 (Pre-training)**: 通常使用 `FP32` 或 `BFloat16` 来保证模型训练的稳定性和最终精度。
    - **微调 (Fine-tuning) & 推理 (Inference)**: 可以使用量化后的低精度模型（如 `INT8`, `INT4`）。这使得在消费级 GPU（如 `A10`）上微调和运行大模型成为可能，极大地降低了应用门槛。

## 9. 总结
本节课程深入探讨了**`Scaling Law`（扩展定律）**及其在大语言模型训练中的核心作用。`Scaling Law` 指出，模型的性能与**模型参数量（N）**、**数据集大小（D）**和**计算量（Compute）**三者之间存在可预测的幂率关系。

课程首先介绍了 `Scaling Law` 的基本概念，并解释了其关键变量 `N` 和 `D`。随后，通过 `DeepMind` 的具体公式 $L(N, D) = E + \frac{A}{N^\alpha} + \frac{B}{D^\beta}$ 和 `Llama 3` 的实例，展示了如何量化预测模型性能。

一个重要的衍伸理论是 **`Chinchilla Law`**，它提出了 `D ≈ 20 × N` 的最优数据-参数配比。然而，`Meta` 的 `Llama 3` 等最新模型通过采用远超此比例的**超大规模、高质量数据集**，证明了**数据质量**在提升模型性能上的决定性作用，突破了传统 `Scaling Law` 的认知局限。

在计算量估算方面，课程介绍了 `C ≈ 6 × N × D` 的实用公式，并用其成功估算了 `GPT-4` 长达数月的训练周期。最后，通过对比 `A100` 与 `H100` GPU 的性能，并讲解 `FP32`、`FP16`、`INT8` 等不同数值精度的应用场景，揭示了硬件性能和量化技术在平衡训练成本与效率中的关键角色。

总体而言，理解 `Scaling Law` 及其演进，对于规划模型训练、分配资源预算、以及把握大模型技术的发展趋势至关重要。