---
title: Transformer
draft: false
tags:
  - AI
---
 

# 一 引言
Transformer 是一种用于处理序列数据的深度学习模型，最初由 Vaswani 等人在 2017 年的论文[《Attention Is All You Need》](https://arxiv.org/abs/1706.03762)中提出。它主要应用于自然语言处理（NLP）任务，并且因其在多个 NLP 基准测试中的出色表现而迅速流行。

## 1.1 历史发展

1. **早期神经网络模型**：在 Transformer 之前，处理序列数据的主要模型是递归神经网络（RNN）和长短期记忆网络（LSTM）。这些模型在捕捉序列中的依赖关系方面表现良好，但存在计算效率低、难以并行化等问题。
    
2. **注意力机制的引入**：注意力机制最初在机器翻译任务中引入，用于解决 RNN 模型难以处理长距离依赖的问题。它通过为序列中的每个元素分配不同的权重，显著提高了模型的性能。
    
3. **Transformer 的提出**：Transformer 模型完全基于注意力机制，舍弃了传统的 RNN 结构。它通过多头自注意力机制和前馈神经网络来处理输入序列，实现了高效并行计算。
    

## 1.2 组成结构

Transformer 模型由编码器（Encoder）和解码器（Decoder）两部分组成：

1. **编码器**：由多个编码层堆叠而成，每个编码层包括以下组件：
    
    - 多头自注意力机制（Multi-head Self-Attention）
    - 前馈神经网络（Feedforward Neural Network）
    - 残差连接和层归一化（Residual Connection and Layer Normalization）
2. **解码器**：与编码器类似，但每个解码层除了包含上述组件外，还包括：
    
    - 编码器-解码器注意力机制（Encoder-Decoder Attention），用于结合编码器输出的信息
3. **位置编码**：由于 Transformer 模型不具备处理序列顺序的天然能力，引入了位置编码（Positional Encoding），通过在输入序列中加入位置信息来保持序列顺序。
    
![image.png](https://build-web.oss-cn-qingdao.aliyuncs.com/my_pic_file/20240721074209.png)

## 1.3 应用场景

Transformer 模型在多个领域取得了广泛应用，主要包括：

1. **自然语言处理（NLP）**：
    
    - 机器翻译（如 Google Translate）
    - 文本生成（如 OpenAI 的 GPT 系列模型）
    - 文本摘要
    - 情感分析
    - 语音识别
2. **计算机视觉**：
    
    - 图像分类（如 Vision Transformer, ViT）
    - 目标检测
    - 图像生成
3. **其他领域**：
    
    - 推荐系统
    - 时间序列预测
    - 生物信息学（如蛋白质结构预测）

Transformer 模型的灵活性和强大的表示能力使其在各种任务中取得了显著的成功，并激发了大量基于 Transformer 的研究和改进。

>[!question] Transformer、RNN和CNN本质上都是在做加权求和，那为什么是Transformer更有优势呢？到底是如何影响到最后结果的？
>

我们就要从其框架组成上去理解
# 二 为什么编解码
Transformer的特殊地方是注意力机制，<font color="red">理解Transformer的关键地方是编码和解码的结构</font>，编码和解码的作用是起到整个框架的作用，<font color="#ff0000">注意力机制是在这整个框架下为了满足某种特定的任务而产生的，做出针对性的优化</font>（就像是计算机硬件中，冯诺依曼架构和显卡之间的关系）

这张图展示的是基于Transformer发展起来的大语言模型关系图，<font color="#ff0000">灰色分支</font>（Decode-Only）是以GPT为代表的<font color="#ff0000">生成式大语言模型</font>，只保留transformer的<font color="#ff0000">decode</font>部分，<font color="#ff0000">侧重于生成语句内容</font>；<font color="#ff0000">浅红色分支</font>（Encode-Only）是以BERT为代表的<font color="#ff0000">大语言模型</font>，只保留Transformer的<font color="#ff0000">encoder</font>部分，侧重于<font color="#ff0000">学习和理解语句内容</font>；<font color="#ff0000">绿色部分</font>（Encode-Decode）是以UL2为代表的大语言模型，它们是帮助GPT或者BERT来<font color="#ff0000">增强功能的工具</font>。
![image.png](https://build-web.oss-cn-qingdao.aliyuncs.com/my_pic_file/20240721090338.png)

>[!question] 为什么会有这三个分叉，这三个分叉会有这样的功能区别？
>

为了解决上面的问题，就要先了解所谓的编码和解码到底是一个什么码
## 2.1 什么是码
### 2.1.1 RNN
在介绍码之前，先了解下RNN
RNN，即循环神经网络，主要用于NLP领域，它和CNN（卷积神经网络）都属于深度学习，RNN主要是用于解决序列类的问题，是不能并行运行（语言中，一个语句的语义主要体现在上下文的语境当中，有先后关系），RNN之所以能够处理语言，就是通过循环结构直接把语言之间的先后关系给包含进去，常用的模型有LSTM,GRU等
![image.png](https://build-web.oss-cn-qingdao.aliyuncs.com/my_pic_file/20240721092619.png)

RNN是为了解决seq2seq的问题，也就是输入的语句如何与输出的语句如何对应起来，因此引入了编码和解码的结构。

到了Transformer，并没有在RNN的基础上改进，而是另起炉灶，但保留了编码和解码的部分，Transformer论文的作者说Transformer和RNN不是一个技术路线。有学者发表论文说，从数学角度，Transformer和RNN、CNN是一致的

>[!question]  Transformer和RNN、CNN到底是怎么一致的？ 后面再说
>

### 2.1.2 码
简单来说，码就是将语句中的符号、发音等形式剥离掉后剩下的语义关系。

>[!info] 语义是由上下文所表达的环境所决定的


在古代，学习一门语言，一定是找到一个事物作为媒介，通过这个媒介找到各自对应的语言表达，比如一个中国人和一个英国人，这个苹果就是媒介，英国人指着苹果说apple，中国人指着苹果说苹果，那么对应的关系就是：苹果-🍎-apple，慢慢积累，就行成了一个语料对应关系库
>[!tip] 啊哈时刻
>1. 从上面例子我联想到《万神殿第二季》中人类从碳基生物到硅基生物的里程碑式的突破，斯蒂芬·霍尔特开发了一种先进的神经网络扫描技术，能够把人类的复杂情感数字化，这和上面的情况是不是很类似
>2. 陆奇提出过一个思考框架，叫做“感知-思考-实现”，首要的是感知，现在人工智能能够通过语言感知到人，也就是说能理解人，但是我们直到，人与人之间交流信息，可不只有语言，还有肢体语言，表情，触觉等等，尤其是爱的表达



机器翻译只能针对纯文本，所以只能通过大量文本的上下文去确定词和词之间的关系

>[!question] 那问题来了，词和词之间的关系应该用什么来表示?

1. 因为是需要计算机，所以他们之间的关系应该是数字化的
2. 因为要表示语义之间的相互关系，语义关系数字化后的数值要能体现出真正的语义关系

>[!question] 第二点中，我们该如何数值化，表达出文本的语义关系？
>

我们可以通过高维向量来表达出来，举个例子![image.png](https://build-web.oss-cn-qingdao.aliyuncs.com/my_pic_file/20240721135216.png)
可以看到，香蕉和猴子的距离相近，而和原子能的距离非常远

通过高维向量可以表示出语义之间的关系，那该如何做呢？机器学习中有两种方法可以借鉴一下，一种是分词器（tokenier)，一种是One-hot

## 2.2 分词器和one-hot

分词器是将每一个不同的token分配一个独立的ID，词语向量投射到一根一维的数轴上。
one-hot编码是将不同的token赋予一个新的维度
![image.png](https://build-web.oss-cn-qingdao.aliyuncs.com/my_pic_file/20240721140020.png)

分词器和one-hot分别代表了两种极端
分词器表示的信息密度过于集中，过于集中的坏处是两个互不关联的两个词可能会距离很相近；而one-hot编码正好和它相反，表达的信息密度过于稀疏，一个词一个维度，它们之间是正交的，互不关联性很强，但到原点的距离都为1，这就形成了一个高维球面。

各自缺点：
- 独热编码的问题在于空间维度过高，token之间的关系全都是靠维度去体现的，并没有把空间的长度利用起来
- 分词器的问题在于token之间全都用长度表示，并没有把空间维度利用起来
这两种方法代表了对token数字化的两种极端

解决方法：
找到空间维度没那么高，维度之间长度不一的空间来表示即可，这就是<span style="background:#ff4d4f">潜空间</span>

如何找到这个潜空间呢？
有两种方法，一种是在分词器方法基础上进行升维；一种是在one-hot编码基础上进行降维。
一般，降维的难度比升维的小，毕竟压缩数据更简单

>[!question]  那如何进行降维？  
>在机器学习中，常用降维的方法是PCA，这里的降维方法和PCA一样，都要用到线性代数中的空间变换
# 三 矩阵和空间变换基础
学习资料：
	[特征值究竟体现了矩阵的什么特征？]([【无痛线代】特征值究竟体现了矩阵的什么特征？_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1TH4y1L7PV/?spm_id_from=333.337.search-card.all.click&vd_source=cff3eef3abcdb3fcf7537244dd23cb21))
	[线性空间]([【无痛线代】什么？解题就是在线性空间里找基？_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1NC4y1J7UL/?spm_id_from=333.337.search-card.all.click&vd_source=cff3eef3abcdb3fcf7537244dd23cb21))
	[[空间变换]]


# 四 神经网络基础
一个神经网络的隐藏层，其实就是在进行一次空间变换，其中隐藏层神经元的个数，就是变换后的空间的维度，代表你可以升维和降维。
神经网络的数学表达式写出来也可以看成是一个矩阵运算。显卡为什么对神经网络来说这么重要，显卡本身就是用来出来三维空间的空间变换，空间变换本质上就是一堆矩阵和线性计算，而神经网络本质上也是矩阵和线性计算

## 4.1 神经网络和矩阵的区别
神经网络和矩阵还是有不同的，主要有两个：
- 一个神经元的一层运算是除了有乘法，还有加法，也就是加上偏置b
- 神经网络中有激活函数，引入非线性性，矩阵运算后，即空间变换前后，点和点是一一对应的，而神经网络不一样，有了激活函数，可以将很多点投射到一个点上。

## 4.2 神经网络的升维和降维
2维的数据，乘以矩阵A（2×10），变化到10维。
![image.png](https://build-web.oss-cn-qingdao.aliyuncs.com/my_pic_file/20240723214143.png)

前面空间变换中，我们知道，矩阵可以完成对向量的拉伸和缩放，也就是说矩阵的作用是操作向量，矩阵也就能起到对向量升维度的作用。

![image.png](https://build-web.oss-cn-qingdao.aliyuncs.com/my_pic_file/20240723214940.png)
上图中，在二维平面内，很难把点分开，放到三维空间中，就能找到一个平面，很好地区分它们。继续推导，如果三维不能分开，那么升到4维、5维...，终有一个超平面将其划分

神将网络的构成是输入层，隐藏层，输出层，其中隐藏层是非常重要的。下图是神经网络的示意图，我们可以看到，隐藏层的随着层级深入，神经元数量在减小，这是为什么

![image.png](https://build-web.oss-cn-qingdao.aliyuncs.com/my_pic_file/20240723215819.png)

举个例子，人的表情识别，现实中通过图片得到的数据是一个一个的像素点，假设有3500个像素点，即3500个神经元，我们可以通过前额动作、眉毛动作...识别人的心情，所以需要将前额动作的像素点投射到一个点，即前额动作，类似地，3500个像素点被压缩到了8个神经元。
![image.png](https://build-web.oss-cn-qingdao.aliyuncs.com/my_pic_file/20240723220553.png)


>[!question]  为什么神经网络需要那么多层
![image.png](https://build-web.oss-cn-qingdao.aliyuncs.com/my_pic_file/20240723221346.png)
隐藏层的层数，代表了神经网络对数据的抽象程度，隐藏层越深，抽象程度越高


# 五 词嵌入
在了解了神经网络中的升维和降维后，我们就能理解编码和解码就好多了。
编码就是先把文本的token进行one-hot编码，然后对其进行降维，这就相当于是把语义投射到潜空间中，把高维空间投射到低维空间，这个过程叫embeding，就是嵌入。
在自然语言领域，嵌入就是词嵌入，通过矩阵乘法这样的方式实现嵌入的，将token投入到潜空间的矩阵叫做嵌入矩阵。
基于潜空间实现翻译的可能就大大增加了，可以分别将两种语言投入到两个独立的潜空间中，然后通过算法，把两个潜空间融合起来，实现翻译，这是一种方法，实现翻译的方法很多，根本上还是要找到两种语言共同的潜空间，以此为中介，实现翻译，先对语言编码，然后用潜空间解码，怎么在潜空间中实现解码计算，就是纯粹的数学计算了

上面我们一直在强调潜空间，潜空间到底是什么，其实就是AI能做的事情，使得AI不再像哲学家拉塞尔说的“中文思想实验”那样，即：AI是个不懂英文的，它会根据中英文对照手册，类似于key-value那样，你输入中文，它找到对应英文，输出出来。

![image.png](https://build-web.oss-cn-qingdao.aliyuncs.com/my_pic_file/20240724214155.png)

潜空间是什么，就是token被嵌入后，变成了多维的向量，向量的不同维度，代表了不同场景下的语义，使得语义可以被量化
![image.png](https://build-web.oss-cn-qingdao.aliyuncs.com/my_pic_file/20240724215027.png)

潜空间和前面提到的中英文对照手册相比，最大的不同是，潜空间是连续的，就是即便是遇到了在此之前没有学过的情况，也可以在潜空间中找到对应的对象，找出对应的关系；而手册不行，会很死板，如果遇到手册没有的，就没法应对超越规则之外的情况。

# 六 Word2Vec
如何才能将语言的token投射到潜空间中，也就是找到实现降维的嵌入矩阵，需要个方法。Word2Vec是其中的一个方法。
传统的机器学习模型的目的是为了完成某个任务，比如输入一个猫狗照片，能给识别出来，而Word2Vec是为了得到嵌入矩阵，为了得到参数，做个类别的话，一般的模型类似于作家培训班，目的是把作家培训出来，而Word2Vec是编词典，编出的词典给模型去用，Word2Vec是这样做，带来的直接差别就是不需要激活函数，计算更简单，具体什么意思呢，我们一步一步来看。
编码和解码的原理是这样的，输入一个token，编码成要给词向量，词向量经过解码，又变成了token，如果没有问题，解码回去的token和输入的token应该是一样的，用这种方法去训练是否可以，看起来是没有问题，但是没有办法实现的，因为训练模型过程一定有一个模型计算结果，结果和正确答案是有差异的，然后将差异反向传播回去，去修正参数，进一步迭代训练。
如果是这种情况，是不能训练的，因为不论输入的向量是什么，前面和后边的两个矩阵，是伪逆关系，也就是说，他们相乘之后，是一个单位矩阵，它就一定是相等的。

![image.png](https://build-web.oss-cn-qingdao.aliyuncs.com/my_pic_file/20240725073644.png)

要想真正地完成训练，还需要在这个思路上做一些调整，具体的方法，就是谷歌论文中说的，有两种，一个是cbow，一个是skip-gram

## 6.1 CBOW
CBOW的原理是这样的，输入的不再是一个token，而是准备奇数个token，假如5个token，把中间这个token拿掉，根据是剩余四个token，分别与同一个嵌入矩阵相乘，把它的潜空间里的词向量之后，再把这四个向量加在一起，合成一个向量，然后再对这个和向量进行解码，这个时候损失函数就会定量去看和向量解码后的token是否和拿掉的中间token一样的，如果不一样，就要去修改参数。

![image.png](https://build-web.oss-cn-qingdao.aliyuncs.com/my_pic_file/20240725075515.png)

为什么把上下四个单词的向量加在一起，就应该得到中间那个词的向量呢？
我们可以把它和我们高中学习的力的分解和合成就比较容易理解了![image.png](https://build-web.oss-cn-qingdao.aliyuncs.com/my_pic_file/20240725205631.png)
token的语义是由上下文的语义环境决定的，我们把其余4个token的向量看作是已知力的方向，中间缺的token所对应的词向量看作是已知分力的合力，也就是说缺失的token的词向量应该是已知词向量的和，反过来，如果中间缺失的token的词向量做向量分解，也应该能获得其他上下文token的词向量。

有人可能会反驳说，比如“__ 苹果”，可能是红、绿、便宜等等，这些词都正确，不就是和上面说的冲突了？

首先这是给出的上下文长度不够长，训练数据少导致的。再一个是Word2Vec的训练目的不是为了让模型具备完形填空的能力，而是让它能训练出体现语义的嵌入矩阵。即便在训练的数据中同时出现“红苹果"，”黄苹果“，”绿苹果"，下次你输入'苹果’的时候，仍然给不出你希望的答案，这也不重要，因为Word2Vec的目的本来就不是这个，重要的是经过训练之后，“红苹果"，”黄苹果“，”绿苹果"的语义一定是比较接近的关系。前面说过Word2Vec提供了一个对语义最初的理解，它训练完之后，体现的是单个语义之间的联系，就是一个词典的作用，词典中解释一个词也是通过其他词来解释的。Word2Vec生成的潜空间，就是用其他词向量合成目标词向量。
从这我们可以看出，Word2Vec训练出的潜空间的词义是不依赖作者的主观意图的，是一种客观的表达，这个客观性是和整个语言环境绑定在一起的，而一个作者根据自己的主观意图把许多词汇组成在一起，才决定了作者所要表达的意图，才表现出来主观性，体现出不同人想表达的不同内容，还体现在作者选择了不同的词和不同的顺序才体现出主观性（体现语义的主观性，是tansformer的任务了，即注意力机制需要做的事情）。

## 6.2 Skip-gram
Skio-gram的原理和CBOW的正相反，还是把词向量当作力的方向和大小，我们已知一个合力，可以推到出其他力的方向和大小。
![image.png](https://build-web.oss-cn-qingdao.aliyuncs.com/my_pic_file/20240725213140.png)

## 6.3 总结
CBOW和Skip-gram都是自监督学习，不需要认为打标签，自己扣掉单词自己训练即可
![image.png](https://build-web.oss-cn-qingdao.aliyuncs.com/my_pic_file/20240725213730.png)
从上面可以看出，Word2Vec可以看作是只有一层的神经网络，这个神经网络里没有偏置b，激活函数，从刚才解释的角度理解，W和W' 似乎只有一个即可，因为W会把独热编码投射到潜空间，那W‘ 就是把潜空间的词向量还原成独热编码，这就说W和W’互为伪逆矩阵，相乘为单位矩阵，但在实际中，W和W'是分别进行训练的，估计和计算复杂都有关，因为求逆是非常耗费资源的。

# 七 注意力
通过前面的编解码、潜空间、神经网络的铺垫，正式介绍transformer。
![image.png](https://build-web.oss-cn-qingdao.aliyuncs.com/my_pic_file/20240725220846.png)

- 在训练好，进行推理的情况下，如果是翻译，左边输入中文，经过翻译，右边输出英文
- 进行训练，那么左边和右边都是输入，分别将中文和英文对应的语料输入到模型中，输出部分在最上面，有损失函数，通过反向传播，再去修改模型里面的参数
- 再看看下面的Input Embedding和Output Embedding这一层其实已经有一个嵌入矩阵了，这个矩阵也不是写死的，也是需要训练过程中调整参数。就是先准备好词典，把单个token的语义都查出来，词和词之间的语义在这个基础上，再去进一步分析和理解，词和词之间的语义理解就是注意力机制，就是图中的橙色模块

## 7.1 注意力机制
了解了注意力机制的作用后，我们来看看其原理
![image.png](https://build-web.oss-cn-qingdao.aliyuncs.com/my_pic_file/20240725222208.png)

作为一组词向量，经过三个矩阵相乘之后，分别得到Q,K,V三个矩阵，在经过一顿运算，最后输出一组词向量，这里有个注意点就是，输入得不是单个词，因为这样词太短，体现不出注意力机制的价值。
输入的时候是输入一组词向量，组成一个数据矩阵，经过与Wq，Wk，Wv矩阵相乘，这就经过了空间变换，得到Q,K,V。
注意力机制里最值得关注的其实是得到Q,K,V之后的操作，操作如下：
1. Q×K的转置 之后得到矩阵A，这个就矩阵A就是注意力得分矩阵，
2. 然后对矩阵A进行缩放，缩放就是除以根号下Dout，这里进行缩放是为了让这些数据尽量分散一些，而不是更多地集中在0和1饱和区。至于为什么要进行缩放，为什么要除以根号下Dout，这其实是从概率分布地角度。

>[!question]  至于为什么要进行缩放，为什么要除以根号下Dout? 这其实是从概率分布地角度

让我们来从概率角度来看下
![image.png](https://build-web.oss-cn-qingdao.aliyuncs.com/my_pic_file/20240726233244.png)

X·Y的转置的标准差为Dout，为了进行缩放除以根号下Dout，softmax本质上也是这样进行的，就是把数据根据它们的相对关系进行归一，这里的softmax不是把整体进行归一，而是逐行归一，也就是softmax之后每一行加起来是1，最后得到的按行归一的注意力得分A‘，再和V相乘进行计算，这样做的意义是什么呢？

>[!question] 最后得到的按行归一的注意力得分A‘，再和V相乘进行计算，这样做的意义是什么呢？
>为了搞明白这么做的意义，我们先再一次明确我们的目标，我们希望注意力机制解决什么问题

前面讲到输入的是一组词向量，不是单个的，词向量是已经具备一些基础词意的，但这个语义是受限的，在还没有进行注意力计算之前，词向量的这个词义是字典里的词意，是客观的词意，当个人将词语进行不同的组合表达自己的观点等，这个时候词才有了主观的词意，才具备了主观性，所以是词向量上下文组织方式才给这段文字赋予了主观性的语义，这个主观语义是在客观语义的基础上扩张和修改而来的，而扩张和修改的方法，一定是隐藏在上下文中，比如”美女“这个词，”美女，能加个微信吗“和”美女，请让一下“，同样是”美女“表达的语义是不一样的，这个时候，这个”美丽“的权重程度就要大幅调低了，注意力机制需要搞定的就是要识别出因上下文关联，而对词典中原本客观的语义进行调整和改变的幅度，这个时候就能知道Q,K,V为什么要这样的相乘，尤其是A’·V，V相当于从词典中查找出来的客观语义，而A'是相当于通过上下文关联而产生的修改系数。

为什么A'就能表达上下文关联产生的修改系数，这里的关键就是Q·K的转置，这里理解不能用空间变换去理解，而是两个矩阵之间做内积，内积是用来表示一个向量在另一个向量上的投影，投影长度的大小表示两两之间的相关关系强弱
![image.png](https://build-web.oss-cn-qingdao.aliyuncs.com/my_pic_file/20240727084000.png)

q1和k1是指每一行代表一个词向量，相乘之后的到【a1，2】，代表相关性强弱，即注意力得分矩阵A
![image.png](https://build-web.oss-cn-qingdao.aliyuncs.com/my_pic_file/20240727091019.png)

如上图所示，得到矩阵A之后进行归一化，得到softmax矩阵T，这个矩阵还是表示词向量之间的关系，只是归一化到了0--1之间，然后和V矩阵相乘，得到矩阵V'，V’式经过修正后的矩阵，修正后的规则是什么呢？我们来看【v‘2，2】，能对其产生影响的是V矩阵中紫色列，如果有很多列，到底是那一列对其产生的影响大，这就由矩阵T决定。

再看注意力机制，q和k相乘是得到了一组词向量自己和自己之间的关系，即矩阵A，然后再把相互关系去修正词向量V，得到修正后的V'。从这里看到，V’和V相比，这里修正后得到的词向量，他们都会根据上下文去进行修正，也就是说V‘中不仅包含词的客观语义外，还有上下文的主观语义
# 八 理解Q和V
 现在有两个问题是：
 1. 为什么使用Q和V两个矩阵相乘，而不是用一个矩阵去训练出矩阵A呢，即两个矩阵相乘去训练和直接用一个矩阵去训练的区别是什么
 2. 即便是使用类似二次型，为什么不能只用一个W矩阵呢，自己和自己的转置相乘不也一样吗


我们先来回答第一个问题，我们可以的看到如下图所示![image.png](https://build-web.oss-cn-qingdao.aliyuncs.com/my_pic_file/20240727181738.png)
如果只用一个矩阵相乘的话，输入的X到得到矩阵A，这是一个线性变化，只能表示线性关系，而如果俩矩阵相乘，也就是把中间Wq和Wk用结合律先算一下，最终得到X·WA·XT，这就是一个二次型，我们知道二次型是可以表示非线性关系的，也就是说有更强的表达能力。
这里选择两个矩阵相乘，而非一个矩阵的方式，某种程度上，是给注意力机制加入非线性因素，让模型可以表达一些更复杂的情况。

再来看第二个问题，从数学角度看，矩阵自己和自己的转置相乘，得到的是一个对称矩阵，看起来和前面的Wq和Wk相乘有点不一样，但本质上还是一样的。如下图![image.png](https://build-web.oss-cn-qingdao.aliyuncs.com/my_pic_file/20240727185348.png)
B矩阵就可以变成一个对称矩阵
那到底该如何理解这个问题呢，即为什么要将q和k单独表示？
其实这里提供一个理解的角度，前面说过，语义分为客观语义和主观语义，主观语义可以继续分为设定语义和表达语义，而q和k能表达设定语义和表达语义的功能，这里是没有特指哪个是设定语义，哪个是表达语义，设定语义和表达语义纯粹是逻辑上的划分，这么划分有个好处就是能够把主观语义的两种不同功能给区分开，理解起来更容易。比如在训练的时候，精挑细选后的数据不可能存在表达语义和设定语义自我矛盾的情况，如果发现有矛盾，有差异了，也就是说注意力积分A得到的积分偏小了，代表着当前的参数是有问题的。这就进行反向传播，调整Wq和Wk的参数，使得q和k相乘尽可能地大，这一点可以靠反向传播算法可以保证的。

明白了以上这一点，我们再来看，如果训练的数据很多，不同形式不同观点的数据都有，每个数据都会对模型里的参数产生影响，等到最后训练好之后，这个数据应该是所有数据表达语义的一个交集，面对这样的情况，如果模型只能表达客观语义和主观语义，而不能把设定语义和表达语义区分开，即Wq和Wk不能区分开，那得到的交集只能是基于同一个客观语义框架下的表达，在统一的世界观和价值观下，对于物理模型，这种方式很合适，因为理想情况下，在物理领域，不论在什么尺度下，模型都是统一的，但是对于人类的语言来说，这种方式就不够了。并存不同的思想，其实就是在不同的设定语义之下，最后得到的观点可能并不相同，甚至截然相反，而同时用同一套客观语义表达出来。

word2vec是训练出来的词向量，是可能有多义词的情况，从多个语义中选出一个进行表达，就是注意力要做的事情。
# 九 交叉注意力
自注意力和交叉注意力的核心仍然是QKV三个矩阵，在自注意力机制里，生成的QKV是相同的数据，在交叉注意力中，Q,K,V生成的数据不一样。做一个类比的话，自注意力机制是闷头学，都是自己从原有的材料里面中总结出来的，这就要先理解材料里的设定语义，再根据设定语义去理解表达语义；而交叉注意力，则像是手边有一个参考资料，省掉了理解设定语义的过程，因为这部分已经在参考资料中了，但这种方式学习起来比较被动，只能在表达语义这种很浅的层次去学到知识，虽然能记住答案，但是换一种题目，就不行了，如果这个模型用作翻译，这是没有问题的，在翻译过程中，交叉注意力反而是一种校准。![image.png](https://build-web.oss-cn-qingdao.aliyuncs.com/my_pic_file/20240727205441.png)
现在我们就能理解transformer中解码部分比编码部分多的那一块，就是用来做交叉注意力的。其中的Nx代表的是多层，解码层的每一层都会和编码器的结果做参考，然后比较相互之间的差异，每做一次注意力计算，都需要校准一次
![image.png](https://build-web.oss-cn-qingdao.aliyuncs.com/my_pic_file/20240727205633.png)

## 9.1 关于transformer的训练和推理的流程
transformer在进行训练的时候，有编码和解码两部分，是可以并行训练的，比如说让transformer进行中英文翻译，”好久不见“输入编码器，”long time no see"输入解码器，然后逐渐往上运算，通过交叉注意力机制得到损失函数，这个损失函数就是编码器和解码器他们都会得到的潜空间的词向量，损失函数来衡量他们之间的差异，得到的损失函数值再去做反向传播，去修改模型里的参数，最后达到他们的潜空间中的词是可以对应起来
![image.png](https://build-web.oss-cn-qingdao.aliyuncs.com/my_pic_file/20240727211112.png)

以上是训练的过程，推理的过程就稍微有些麻烦， 按照我们前面的理解，应该是将中文输入编码器，得到一个词向量，然后 通过解码器还原出token，解出英文。如果是一个句子还好说，输入和输出是一一对应的，矩阵在运算的时候，就相当于一个数据流，经过数据流之后，数据的个数是不会发生变化的，是一个线性变化。但现实的情况是会有大量的语句输入进来，再按照前面说的，这样做就行不通的，所以需要解决seq2seq的问题，最开始解决方式是RNN。
transformer在这里也是使用RNN的思想，尤其解码器部分，输入部分不变，关键是要生成的时候怎么去生成词，不是并行生成，而是一个一个生成，这个过程利用到了RNN的思想。
具体做法：
![image.png](https://build-web.oss-cn-qingdao.aliyuncs.com/my_pic_file/20240728075128.png)

在编码器部分，先把“好久不见”输入进去“，然后它会生成一组前空间离的词向量，在解码器部分，需要输入一个代表开始的特殊符号，输入之后，经过交叉注意力进行计算，得到的结果经过升维和softmax计算后，会将词汇表中的所有token计算成一个概率，概率大的为结果，找个结果代表的是下一个token是什么，假如得到的是”long“，然后”long“又传递到下一个编码器，计算后得到”time“，以此类推，直至得到结束符号。 找个过程相当于一个接一个的将token解码出来，这个就是解决seq2seq的过程

>[!info] 为什么很多大预言模型，要么只有解码器，要么只有编码器？
>其实这里可以看出，这里的解码器和我们最开始理解的不一样，这里的解码器是由编码和解码功能的，并不是将潜空间里的词向量还原出来，而是有一个输入的token，编码成潜空间的词向量，通过交叉注意力，对比的方式比较是否一致，所以解码器也是有编码功能的。
>像GPT那样的模型，只有右边解码的部分，是将你输入的语言编码成词向量，把你输入的内容看成是已经是生成过的内容，再在这个基础上继续进行生成。
>至于我们输入一段文章，什么也不说，模型怎么知道你是需要概况呢，还是续写，还是翻译，这个就需要看模型怎么去训练了，即给模型训练一个功能，在默认情况下，进行默认的一个功能。

>[!info]  多头注意力机制 知识点
>多头注意力其实就是能力更强的CNN，词向量的维度对应的是卷积里的通道，多头对应的是卷积核
# 十 位置编码
![image.png](https://build-web.oss-cn-qingdao.aliyuncs.com/my_pic_file/20240728092608.png)


## 10.1 绝对位置编码
需要位置编码的原因是语言是有规则有序列的，比如”我打你“和”你打我“是两种不同的意思，如果没有位置编码，transformer会将所有的token都输入进去并行计算，没有序列可言，语言所携带的信息就没有办法体现出来了，所以需要保证输入的语句在保持并行计算的同时，还能体现出他们的先后顺序，在矩阵乘法计算时，这种先后顺序是表现不出来的，所以位置编码就应运而生。
有两种方法添加上位置信息，一个是通过权重，也就是乘法，一个是通过偏置，也就是加法
--- start-multi-column: ID_mx3i
```column-settings
Number of Columns: 2
Largest Column: standard
```
![image.png](https://build-web.oss-cn-qingdao.aliyuncs.com/my_pic_file/20240728094351.png)


--- column-break ---

![image.png](https://build-web.oss-cn-qingdao.aliyuncs.com/my_pic_file/20240728095715.png)

--- end-multi-column


在transformer里面，用的是加法实现的，怀疑这么做的原因是如果使用乘法，位置对词向量的影响就太大，就相当于给模型额外增加了一层结构，而加法，就相当于在一个层里面增加了一个固定偏执系数，从几何角度看，这相当于给不同次序的向量进行不同的平移操作。
接下来，我们来看下原版里transformer怎么实现的。这个P矩阵到底该取什么样的值，至少能保证这个矩阵中的值可以体现出词向量的相互顺序才对，那怎么才能体现这个顺序，这就是绝对位置编码做的事情，即把位置下标，也就是一维的自然数集，投射到一个与词向量维度相同的连续空间中，这样词向量矩阵就能和位置编码矩阵进行相加了。

具体怎么把自然数投射到高维空间中，论文中的公式是这样![image.png](https://build-web.oss-cn-qingdao.aliyuncs.com/my_pic_file/20240728103441.png)
这样是看不出什么来的，那就需要进行逆向推理，由于作者没有说明这一部分，我们进行联想下，看到sin和cos交替出现，是不是想到了傅里叶级数，我们虽然不知道作者是不是这样考虑的，但是我们利用傅里叶级数帮助我们理解如何做的。
![image.png](https://build-web.oss-cn-qingdao.aliyuncs.com/my_pic_file/20240728103633.png)

所谓编码，就是将0，1，到n这样一个自然数进行升维，升到D维，和词向量的维度是相同的，原来是数，现在是向量，具体是什么形式

![image.png](https://build-web.oss-cn-qingdao.aliyuncs.com/my_pic_file/20240728103854.png)

从下图中我们看到每一个格子对应着下面的一个式子，两格两格是一组，通过每一项来得到f(t).

![image.png](https://build-web.oss-cn-qingdao.aliyuncs.com/my_pic_file/20240728113708.png)

有以下几点不同：
1. 我们可以f(x)中，将A1, A2...看成是1， A0看成是0
2. f(x)的项是无限的，直接看成有D项即可
3. 红色虚线框中代表的是频率，f(x)中是等比增加的。而在f(t)中，绿色的变量在分母的指数上，这里我们是可以理解的，从单调性上看，红色虚线框中的式子是单调递减的，最大的就是头一项，即最大值为1（因为指数上的计算为（2·0），所以为1）。那划到刻度上表示如下：![image.png](https://build-web.oss-cn-qingdao.aliyuncs.com/my_pic_file/20240728115104.png)
	这个图中看出，每一项是按照指数的形式进行递减的，不像是傅里叶变换中每一项都是等比变换的。上图中绿色刻度都可以被最小刻度整数倍表达，那我们就可以要求，只要在绿色刻度上，系数都为1，否则都为0，然后把所有不为0的系数写下来，就是上面的f(t)，所以说仍然是一个周期函数

所以说上面的f(t)就是傅里叶变换公式，是一个周期函数。得到的这个函数有什么特征呢，我们就可以根据傅里叶级数的公式去理解，
![image.png](https://build-web.oss-cn-qingdao.aliyuncs.com/my_pic_file/20240728140754.png)


![image.png](https://build-web.oss-cn-qingdao.aliyuncs.com/my_pic_file/20240728141307.png)
![image.png](https://build-web.oss-cn-qingdao.aliyuncs.com/my_pic_file/20240728141412.png)


## 10.2 相对位置编码
前面的推导是绝对位置编码，是针对数据进行修饰，直接让数据携带了位置信息；相对位置编码的思路就不一样了，它会更多地考虑一个词向量和另一个词向量之间的相对位置，这个过程是在注意力机制里发生的，也就是矩阵Q和K的转置相乘的过程中发生的，相对位置编码是针对注意力得分矩阵A进行修饰，让其具备位置信息。

我们借助数学公式来看下，从下图中我们可以看出，加入相对位置矩阵后拆分成4个矩阵，第一个矩阵是没有相对位置信息的，其余三个都有相对位置矩阵P，也就是说剩余三个矩阵与位置信息有关，我们是希望得到相对位置编码，比如红框部分代表q词向量和k词向量的相对关系，把相对关系表现出来了。
![image.png](https://build-web.oss-cn-qingdao.aliyuncs.com/my_pic_file/20240728155733.png)

需要改变的是后边三项和相对位置有关的项，既依赖于q又依赖于k，而不是依赖于q-k，这是什么意思呢，我们来看标出红框的值，注意力得分A在红框处的公式写出来
![image.png](https://build-web.oss-cn-qingdao.aliyuncs.com/my_pic_file/20240728160131.png)

如何将这三部分修改以下，让其依赖于q-k这个相对关系，而不是绝对位置呢？
我们重点来看下灰色部分，因为其既有q又有k，来构造一个g函数来表示f(q,k)，构造出这样的形式后，相当于一行确定后，q这一行里面的每一个元素都是由两部分组成，即g1和g2，从这能够看出来，g1是和绝对位置有关的，g2是和相对位置有关，我们这里只考虑相对位置，所以可以进一步写成g1(0)·g2(q-k)，这样就只和q和k有关了，再进一步构造关系表达式：v·WT·RTq-k，将构造的这个函数去和前面两项进行替换，得到最终的公式

![image.png](https://build-web.oss-cn-qingdao.aliyuncs.com/my_pic_file/20240728160948.png)

相对位置编码，一定是在计算注意力得分矩阵时体现出来，对注意力得分矩阵进行修饰，增加位置信息，还有一个就是旋转位置编码，它用的是乘法。
# 多头注意力
在了解了前面的位置编码，再来了解多头注意力就好理解了。
![image.png](https://build-web.oss-cn-qingdao.aliyuncs.com/my_pic_file/20240728172031.png)

多头就是指①②③，之前只进行一次注意力机制，现在是进行三次，这三次注意力机制里面的系数是各自独立的，也就是说学到的各不相同，得到的三个结果也不一样，三个结果再拼在一起，与矩阵W相乘得到最终结果Y。
为什么要这样做，而不是直接用要给9维的w矩阵进行训练呢
![image.png](https://build-web.oss-cn-qingdao.aliyuncs.com/my_pic_file/20240728172607.png)

绿色代表三个头的第一维数据，紫色代表三个头的第二维数据，蓝色代表三个头的第三维数据，也就是说按照对应的维度进行分组的，词向量的维度某种程度上可以理解成是通道，和RGB是相同的，三个头的相同维度得到的数据，如果定性去想，他们语义应该是相近的，组成一组后形成一个综合的语义，三个不同的语义就可以看成图片里不同的通道，经过系数相加得到一个值，如果比作CNN的话，通道之间的相乘和相加，就相当于1×1的卷积核，1×1的卷积核的作用就是用来打通通道的，组里面进行的计算就是CNN里的卷积操作。

上面我们是定性的做了解释，到底是不是这样呢，用数学来解释一下。
有一篇论文中讲述transformer和CNN的关系，是这样解释的，
下面是相对位置编码的公式，为了简化问题，用了最简单的情况，就是输入的数据全都是0，只考虑有颜色的部分，为了让问题更简化，设W为单位矩阵
![image.png](https://build-web.oss-cn-qingdao.aliyuncs.com/my_pic_file/20240728174025.png)


![image.png](https://build-web.oss-cn-qingdao.aliyuncs.com/my_pic_file/20240728175032.png)





# 掩码等

# 参考
[从编解码和词嵌入开始，一步一步理解Transformer，注意力机制(Attention)的本质是卷积神经网络(CNN)_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1XH4y1T76e/?spm_id_from=333.999.0.0&vd_source=cff3eef3abcdb3fcf7537244dd23cb21)